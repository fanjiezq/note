# 部署架构
+ 单节点模式:
	- 优点：简单易用，对计算机资源要求很少，而且单机不需要同步数据，数据天然一致性
	- 缺点：单个节点并发能力有限，计算机资源容易成为性能瓶颈，而且单节点数据容易丢失，对于有数据安全性要求的应用不适合。
+ 主从模式:
	- 原理：主从即一个主节点多个从节点，主节点负责数据读写，从节点负责从主节点同步数据，并负责读数据请求。
	- 优点：此模式的优点是使用副本分摊了系统读数据的压力，解决了单节点的读瓶颈；同时副本节点与主节点数据一致，主节点宕机副节点可以晋升为主节点
	- 缺点：没有解决主节点写的压力； 主节点宕机以后需要手动将副本节点升级；所有数据存储在单个节点，数据存储数量受限
+ 哨兵模式:
	- 原理：主从模式的优化版本，利用哨兵监控集群节点的状态，主节点宕机以后从节点可以自动晋升为主节点。
	- 优点：拥有主从模式的所有优点；且自动故障恢复
	- 缺点：没有解决主节点写的压力；所有数据存储在单个节点，数据存储数量受限
+ 集群模式:
	- 原理：redis集群采用无中心模式，每个节点都保留集群中所有节点的状态，且与其他所有节点相连。 结构方面依旧是主从结构，主节点数据可读写，从节点负责同步，数据只读。每个主节点都存在从节点，可以在主节点宕机时随时顶替。数据方面，数据分片存存储在不同节点，每个节点只保存整体数据的一部分
	- 优点：数据分片存储，存储的数据量不在受单节点硬件资源限制； 每个主节点都可以堆外提供读写服务，解决了读写压力；主从结构提供了自动故障恢复能力
	- 缺点：硬件资源需求比较多，一个集群至少需要6个节点，3主3从

# 数据持久化
+ 数据持久化是为了保证数据安全提供的功能，让redis在故障恢复后数据也能恢复到故障之前状态。redis一般作为缓存存储系统，很多时候其实并不需要数据持久化，但是如果作为其他用途，类似session保存位置，或者实现延时队列，数据必须进行持久化
+ 数据持久化的两种方式:
	- RDB: RDB持久化是将当前系统数据的快照保存在磁盘，也称快照持久化
		- 原理：1）当触发快照时，redis使用fork复制一份当前进程(父进程)的副本(子进程) 2）父进程继续对外服务，子进程将数据写如到硬盘中的临时文件 3）使用临时文件替换旧快照文件，本次快照完成
		- 使用：1）手动命令触发 2）配置触发规则，比如每一分钟触发一次
		- 优点：RDB方式生成的文件是当前系统数据的快照，其大小等于当前系统数据大小，经过压缩后会更小。在数据恢复过程中，redis只需要加载快照文件，速度很快
		- 缺点：如果系统在两次快照之间宕机，那么这段时间写如和更新的数据就会丢失
		- 注意：在进行快照时，redis的内存用量会显著增大，因为此时内存中不仅保存了系统数据，还保存了fork时父进程的数据。虽然redis利用了copy-on-write技术使得内存实际用量不会扩张为当前的两倍，但是数据量本身比较大的情况下，快照前后内存用量依旧会差别很大
	- AOF:
		- 原理：开启AOF后，redis会将每个写如更新操作指令保存到磁盘，以AOF文件保存。
		- 使用：使用配置文件开启aof
		- 优点：AOF可以记录系统的每一个非查询类操作指令，可以做到数据完全不丢失
		- 缺点：每条更新指令都需要进行磁盘IO，会降低写性能；aof文件存储的是操作指令，那么必然存在大量的数据冗余，导致文件很大；在数据恢复时，aof文件需要重新执行所有操作指令，恢复速度可能很慢
		- 注意：为了提升AOF的性能，AOF写磁盘存在多种可选方式，默认是每个指令只写入到操作系统缓存，至于什么时候写入到磁盘由操作系统决定；很容易想到，这种方式依旧存在数据丢失的可能，那么可以选择定时强制刷新缓存数据到磁盘，比如2秒刷新一次。如果数据绝对不能丢失，也可以选择每条指令都必须立即写如到磁盘，这种方式最安全也最慢。AOF文件通常比RDB文件大很多，数据恢复也慢很多
		- 注意：aof文件的特点会导致它随着时间不断变大，为了缩减其体积，redis提供了aof重写功能，即另外建立一个aof文件， 此文件从原始aof文件重写而来，但是不包含任何冗余指令,文件会小很多。这会存在一个隐藏问题，如果后台aof在重写数据，前台redis同时在往原始aof插入数据，插入操作会被阻塞。会降低系统性能，可以使用no-appendfsync-on-rewrite 参数关闭阻塞，但是这样又会导致部分数据又丢失的风险
	- 混合持久化: 为了保证性能和数据安全，redis4提供混合持久化，混合持久化只发生在aof文件重写过程中，重写后的持久化文件前半段是RDB全量数据，后半段是aof增量数据。优点是的数据安全和恢复快速，缺点是文件可读性差

# 集群数据分配
+ redis集群模式下数据会被均匀分配到集群的各个节点，以此均衡数据的存储和读写压力，那么数据如何合理分配数据，以及如何动态扩容就很重要
+ 插槽分配：redis使用分配插槽来决定数据应该分配到哪个节点。在一个集群中，所有的键会被分配给2^14个插槽，集群启动时，所有主节点都会被分配一部分插槽，比如(0-5000)，在数据插入时，redis计算出key的hash值，然后对 2^14 取模，确定这个key应该被存储到哪个节点
	- 在某些情况我们想要某类key不同的数据被分配到同一个节点，那么可以使用一定规则的key，让redis只取一部分key进行hash.例如：{daily}:00001,{daily}:00002,hash的有效部分是daily，两者会被分配到同一节点
+ 动态扩容：redis的集群支持动态扩容，扩容分为两步，第一步是把新节点加入集群，第二步是重新分配solt，使用redis-trib.rb工具添加或者删除节点，会一步步提示如何添加节点，如何迁移数据

# 集群故障恢复
+ 哨兵模式：
	- 哨兵模式下哨兵每1秒都会向其他库发送ping命令，如果某个哨兵发现某节点没有回应，哨兵认为其主观下线；该哨兵会询问集群其他哨兵是否认为此节点主观下线，如果达到一定数量，此节点被认为客观下线。如果节点是主节点，哨兵会发起故障恢复，选举新的主节点
+ 集群模式：
	- 集群模式下集群中的每个节点每1秒会随机选取5个节点发送心跳。选择(节点A)其中长时间没有回应的节点(节点B)继续发送ping命令，如果依旧没有回应，节点B会被A认为疑似下线，节点A就会在集群广播这一消息，所有其他节点记录这一消息。当集群中某个节点C收集到集群半数以上节点认为B疑似下线，就会将其标记为下线，并且广播
	- 节点被广播下线以后，如果它有从节点，集群就会选择其中一个从节点升级为主节点;如果没有从节点，集群中就会出现一部分插槽没有负责的节点，那么某些数据就会无法保存，集群整体不可用。如果能够容忍某些key可以不保存，可以进行特殊配置，让集群在这种情况下依旧可用

# 内部机理
## 数据管理方式
+ redis默认采用 jemalloc 管理内存，jemalloc 会把内存按照大小划分为大小不同的块，数据存储时按照数据大小进行匹配，保存在最合适的块中，这种管理方式很大程度上减少了内存碎片
+ 对于单个数据，redis封装了一个 redisObject 对象，对象属性包含type,encode,dataref等，所有数据类型都采用此对象封装

## 数据存储方式
+ string类型
	- redisObject存在一个指针指向数据的地址，一般在64位计算机，所以指针一般8字节，当存储string类型数据，如果数据可以由8字节保存，就直接使用指针保存数据，节省内存
	- 当数据的长度超过8字节，小于39字节，采用 embstr 类型保存；超过 39 采用 raw 类型存储。embstr类型将数据结构和数据存储在一块连续的内存，可以让cpu一次性加载所有的数据，比起raw类型，，可以减少一次缓存读取
+ list类型
	- 早期采用压缩链表和双向链表,默认使用压缩链表，节省空间，当数据的长度超过64,或者节点数量超过512，使用双向链表，避免数据量很大，导致压缩链表因为连锁更新产生的很大的性能消耗
	- 3.2之后采用quicklist,就是由压缩链表作为节点组成的双向链表。压缩链表的好处是节点使用连续内存保存，但是因为连锁更新问题会导致频繁的内存申请和释放。双向链表有双指针，会浪费内存且节点在内存中是分散分布的，会导致大量内存碎片。于是结合两者特性设计出quicklist
+ hash类型
	- 底层采用压缩链表和hash表，当hash对象保存的键和值字符串长度都小于64字节，且元素数量少于512，采用压缩链表，否则升级为hash表
+ set类型
	- 底层采用inset 和 hashtable，inset就是一个数组，当元素数量不超过512的时候使用inset，元素去重采用二分法查找。元素数量超过512，升级为hashtable,key用于保存数据
+ zset类型
	- 采用字典 + 跳表，字典的key用于保存数据，value用于存储分值，而跳表利用分值排序，结合两者可以快速定位元素位置

# Hash扩容
- Redis的Hash表实现与java1.7的HashMap非常类似，也是链表数组，使用拉链法解决hash冲突，当拉链太长时进行扩容
- Redis是单线程的，为了防止在扩容过程中导致请求被长时间阻塞，redis采用渐进式扩容。Redis的每个字典创建时都包含两个HashTable(ht0,ht1),一个平时存储数据使用，一个仅仅在扩容的时候使用。触发扩容后，准备将旧表的数据迁移到更大的另一个表，迁移过程是按照数据的桶一个一个迁移的。扩容过程维护一个ReHashIndex,每迁移一个ReHashIndex就加一，直到ReHashIndex == ht0.size()
- 扩容过程中数据的迁移和请求处理过程是在一起的，在扩容时如果来了一个读请求或者写请求，那就先在旧表定位到数据桶的位置，然后写入或者查询数据，然后顺便把这个桶的数据迁移到新表。这种方式可能使得这个请求的时间变长，但是不至于全局阻塞


# 主从同步
+ 全量同步:从节点启动时执行sync命令，主节点接收到命令后将RDB文件发送给从节点，从节点加载到内存，达到主从同步
+ 部分同步:从节点宕机重启以后，在某些条件下执行 psync ，可以做到只同步在宕机期间新增的数据
+ 命令传播:在集群运行期间，主节点会不断的接收到写入命令，会引起主从不同步，每次主节点写数据后都会将写入命令发给从节点，让从节点也执行命令，达到主从同步

# 优化
## 内存使用情况
+ 使用info命令可以查看内存的使用情况。redis的内存使用大体分为两块，1）redis程序本身占用内存, 2）redis存储数据占用的内存。 相比于数据占用的内存，redis本身的内存大小几乎可以忽略不记	

## 碎片率
+ redis默认的 jemalloc 内存分配器可以很好的处理内存碎片，但是随着时间的推移，内存碎片必然会越来越多，所以隔一段时间需要重启一下redis整理内存碎片
+ 使用info命令可以查看内存使用情况，其中几个比较重要的属性需要注意：
	- used_memory: redis为数据分配的内存，如果使用到虚拟内存，也包含在内
	- used_memory_rss: redis占用的操作系统总内存，包含redis程序本身占用内存
	- mem_fragmentation_ratio: 内存碎片比率，该值是used_memory_rss / used_memory的比值
正常情况下 used_memory_rss  > used_memory；如果 used_memory > used_memory_rss 说明用到的虚拟内存，说明系统资源不够了。
正常情况下 mem_fragmentation_ratio > 1，且该值越大，内存碎片比例越大，mem_fragmentation_ratio在1.03左右是比较健康的状态。mem_fragmentation_ratio < 1,说明Redis使用了虚拟内存

## 大块数据
+ redis是单线程的，利用事件驱动模型和多路复用技术实现IO网络读写，处理高并发问题。每个客户端都是一个socket,每个读写请求都会被封装为一个事件，对应一类事件处理器。多路复用程序负责监听所有socket，并将socket的请求发送给事件调度器；事件驱动模型负责将这些请求分类，调度到对应的事件处理器
+ 单线程的高性能基于每个处理都非常快，才不会因为某个请求的阻塞导致整体处理速度变慢。如果存在非常大的数据，无论时查询还是存储，单个value都会导致长时间阻塞，后续请求只能等待。
+ 大块数据产生的长时间阻塞还可能导致主从节点断开重连，导致数据进行全量同步，但是2.8版本以后采用增量复制，解决了这一问题

# 缓存更新策略
+ 缓存更新可能导致缓存与数据库的数据不一致，数据的更新一般是先更新数据库后更新缓存，当线程A,B同时对一个数据进行更新，A先将数据库更新为100,B然后将数据库更新为200,此时数据库是200,缓存也应该更新为200,但是可能因为网络原因，A却在B后面更新了缓存，就导致缓存变成了100,此时缓存就不一致了，为了避免这种不一致的情况，有多种缓存更新策略
	- 针对实时性要求不高的系统，不更新缓存，依赖key的自动失效
	- 先更新数据库再删除缓存，对于更新操作，线程先更新数据库，等到数据库更新成功以后让缓存失效，有极小的概率出现数据不一致问题(线程A查询库得到旧值，线程B先于A更新数据库且将缓存失效，线程A将旧值写入缓存)，但是上述情况发生的概率特别低，所以如果对一致性要求不是绝对严格的场景可以使用这种方式。
	- 延时双删，即在更新数据库操作前后都删除缓存数据，且第二次删除操作进行延时，延时主要为了确保并发的读请求结束，可以将读请求会写的内存再次删除.但是这个策略实现成本太高，而且也并不能保证数据的绝对一致(https://blog.radebit.com/2021/03/30/210.html)
	- 通过第三方程序监控数据库的binlog更新缓存
	- 如果系统足够复杂，也可以采用read through ，write through ，Write Behind Caching 三种模式，其基本思想都是把缓存作为一个单独的服务，数据的更新由缓存服务自己来，对调用方是无感的

# 解决热点数据到导致的缓存击穿问题
+ 覆盖式更新，缓存不设置失效时间，而是使用定时任务，主动定时刷新缓存，适合那些数据实时性不高，key值相对固定的场景。也可以监控mysql的binlog来进行增量更新
+ 采用分级缓存，L1 层失效时间短，L2层失效时间长，如果的L1层没有命中则加锁，然后到数据库查询，并更新L1和L2，在此期间其他请求还是从L2获取数据

# redis缓存失效策略
+ redis作为缓存，很多时候会因为内存空间不够需要清除失效的key，redis 是单线程的，回收数据也会导致系统阻塞，为了保证在key值回收不至于导致服务器被长时间阻塞，redis采用定时扫描 + 惰性删除 + 内存淘汰机制 实现key的回收
	- 定时扫描: redis服务器会定时的扫描系统中的key,每次扫描20个，然后删除其中已经过期的
	- 惰性删除: 如果某些key没有被扫描到，在查询时也会先检查key的过期时间，然后进行删除
	- 内存淘汰: 还有一部分key可能没有被定时扫描到，也没有被惰性删除，此时内存空间又不够了，redis就会选择一部分key进行淘汰，淘汰机制可以配置