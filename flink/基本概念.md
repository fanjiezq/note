# 核心组件
+ ResuorceManager:负责管理 slots 并协调集群资源。ResourceManager 接收来自 JobManager 的资源请求，并将存在空闲 slots 的 TaskManagers 分配给 JobManager 执行任务。Flink 基于不同的部署平台，如 YARN , Mesos，K8s 等提供了不同的资源管理器，当 TaskManagers 没有足够的 slots 来执行任务时，它会向第三方平台发起会话来请求额外的资源。
+ Dispatcher：负责接收客户端提交的执行程序，并传递给 JobManager 。除此之外，它还提供了一个 WEB UI 界面，用于监控作业的执行情况
+ JobManager:JobManagers 接收由 Dispatcher 传递过来的执行程序，该执行程序包含了作业图 (JobGraph)，逻辑数据流图 (logical dataflow graph) 及其所有的 classes 文件以及第三方类库 (libraries) 等等 。紧接着 JobManagers 会将 JobGraph 转换为执行图 (ExecutionGraph)包含了所有可以并发执行的任务，然后JobManagers向 ResourceManager 申请资源来执行该任务，一旦申请到资源(就是TaskManager上的插槽(slot))，就会将执行图分发到真正运行它们的TaskManager上 。而在运行过程中，JobManager会负责所有需要中央协调的操作，比如说检查点（checkpoints）的协调。因此每个作业 (Job) 至少有一个 JobManager；高可用部署下可以有多个 JobManager，其中一个作为 leader，其余的则处于 standby 状态
+ TaskManager:Flink中的工作进程Worker。通常在Flink中会有多个TaskManager运行，每一个TaskManager都包含了一定数量的插槽（slots）。插槽的数量限制了TaskManager能够执行的任务数量。启动之后，TaskManager会向资源管理器注册它的插槽；收到资源管理器的指令后，TaskManager就会将一个或者多个插槽提供给JobManager调用。JobManager就可以向插槽分配任务（tasks）来执行了。在执行过程中，一个TaskManager可以跟其它运行同一应用程序的TaskManager交换数据

# 作业提交流程
1. 使用工具类提交Job到调度器Dispatcher
2. 调度器启动并提交应用到JobManagers
3. JobManager到ResuorceManager申请资源
4. JobManager申请到资源后启动TaskManager执行计算

# 任务槽(Slot)
+ TaskManager是集群中真正负责计算的角色,每个TaskManager都是一个JVM进程,它可能存在一个或者多个线程上执行任务.任务执行的并行性由每个 Task Manager 上可用的任务槽决定
+ 每个任务槽代表一组资源, 例如如果 Task Manager 有四个插槽，那么它将为每个插槽分配 25％ 的内存
+ 可以在任务槽中运行一个或多个线程,同一插槽中的线程共享相同的 JVM, 同一 JVM 中的任务共享 TCP 连接和心跳消息
+ Task Manager 的一个 Slot 代表一个可用线程，该线程具有固定的内存，注意 Slot 只对内存隔离，没有对 CPU 隔离
+ 默认情况下，Flink 允许子任务共享 Slot，即使它们是不同 task 的 subtask，只要它们来自相同的 job,以提高资源利用率
+ 不同的任务可以共享一个Slot,默人所有的Slot都可以被任意任务共享,也可以通过设置共享组设置哪些任务共享一个组的Slot资源,哪些任务必须分配在不同的Slot


# 并行度(parallelism)和任务槽(Slot)
+ Flink程序是并行和分布式运行的, 数据流可以被分区,然后每一步数据转换都是一个单独的operators,operators被划分为operator subtasks,所以每个operators都可以并行执行,perator subtasks就是这个operators的并行度
+ 并行并不是无界的,集群的并行能力受资源约束,在Flink中每个TaskManager都可以并行的执行多个任务,但是并行的最大数量受Slot的约束,如果一个TaskManager只有3个Solt,它就只能并行运行三个Task(不考虑Solt共享)
+ 所以Slot 是指 Taskmanager 的最大并发执行能力;parallelism 是指 taskmanager 实际使用的并发能力


# 任务划分
+ Flink程序正式计算之前会经历几个构建阶段, 数据流图 > Job图 > 执行图 > 物理执行图.
+ Flink程序最终会被分成若干计算任务,分配到各个Slot执行,Task的划分很多时候和我们的代码并不一致,某些算子会被合并到一个Task.合并的规则是如果两个算子的并行度相同,且数据传输形式是one-to-one的,那么两个算子就可以合并

# 时间语义
Flink定义了三类时间:
+ 处理时间（Process Time）数据进入Flink被处理的系统时间（Operator处理数据的系统时间）
+ 摄取时间（Ingestion Time）数据进入Flink的时间，记录被Source节点观察到的系统时间
+ 事件时间（Event Time）数据在数据源产生的时间，一般由事件中的时间戳描述，比如用户日志中的TimeStamp

# 事件时间与WaterMark
+ 当使用事件时间作为处理依据,会存在事件迟到的问题,比如时间窗口1分钟,理论上第60秒的数据到来时第一个时间窗口应该关闭.但是如果因为网络延迟导致第59秒的数据在第60秒以后到来,将无法再进入地一个窗口.
+ WaterMark专用于处理事件迟到,它会为每个事件加一个时间水印,比如想要时间窗口延时5秒关闭,如果某个事件A的发生时间9:00,那么WaterMark设置为8:55,原本应该在事件A到来时关闭时间窗口,现在改为以WaterMark为标准,只有WaterMark等于9:00 的事件到来才会关闭窗口



# 内存管理