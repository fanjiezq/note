Spring 是一个很高级的框架，尽管他的思想很简单，使用很傻瓜，但是他依旧很高级。相比一般框架，它不面向某个具体业务，而是普适的，集合任何系统任何程序都可以使用
IOC就是控制反转，把对象的管理交给容器，程序员可以更专注于业务，他的功能很强大，但是说实话，针对一般情况的使用，优势并不是很明显，比如对象是单例的，我们用单例模式也不是很复杂，我看来它更大的优势是建立起了一套体系，比如对Bean生命周期的管理，对bean生成模式的控制，可以让我们很轻易的对Bean进行批量改造

# 控制反转 VS 依赖注入
+ 控制反转(IOC): 控制反转是一种软件设计思想，面对对象编程完成一个任务需要多个对象合作，一个对象需要其他对象就需要自己创建对象，组织对象的逻辑，处理对象生命周期。对于代码层面来说，这种实现会将多个对象耦合在一起，哪怕面对接口编程也一样与接口耦合。控制反转的思想是引入第三方管家，也被称为容器，负责管理所有资源，包括所有类，对象，接口，文件。所有对象间的依赖关系和生命周期都由容器管理，业务实现需要什么资源直接从容器获取。资源依赖关系从对象控制变为容器控制，所以是控制反转。利用控制反转的方式编写程序，每个对象需要什么资源由外部实现，只需要专注于自己的业务实现，极大降低了各个对象直接的耦合性
+ 依赖注入(DI):依赖注入是控制反转思想的具体实现，比如我们的某个dao需要一个数据库连接Connection对象，以前需要dao对象自己新建Connection对象，有了spring后dao直接告诉容器自己需要这个对象，容器就把对象注入到dao中，dao不需要关心这个连接怎么来的，实现方式如何，它只需要关心自己的业务。当需要切换数据库时，无非就是spring换一个Connection对象的注入到dao，业务代码完全不需要

# Spring Bean生命周期
1. 实例化:创建一个Bean实例，所有属性为默认值
2. 属性赋值:为Bean设置相关属性和依赖
3. 初始化:
    1.初始化前:检查是否实现Aware相关接口，并执行其实现 
    2.初始化前:检查有没有实现BeanPostProcessor,并执行 postProcessBeforeInitialization()
    3.初始化:检查是否实现初始化 InitializingBean ，并执行 afterPropertiesSet()
    4.初始化:检查是否指定了 init-method,并执行其实现
    5.初始化后:检查有没有实现BeanPostProcessor,并执行 postProcessAfterInitialization()
4. 销毁
    1. 检查是否实现销毁回调接口 DisposableBean， 并执行其回调方法 destroy()
    2. 检查是否指定了 detory-method ，并执行其实现

## bean的循环依赖问题
+ bean创建过程中可能存在循环依赖问题,循环依赖问题产生的原因是在bean设计过程中A依赖了B,B依赖了A.而spring是以迭代的方式创建Bean的,即创建Bean的时候检查依赖,遇到存在的依赖的bean创建,则先创建依赖的bean
+ 迭代方式创建Bean对于发现循环依赖来说非常简单,创建过程中为bean做标记,则在迭代过程中.如果存在循环依赖,总会找到自己
+ spring只提供了单例模式下解决bean循环依赖问题的方案,方法是在bean创建完成之前就暴露自己.bean创建过程中遇到依赖会优先从缓存中获取依赖的bean,如果等到bean完全创建成功才将bean实例加入缓存,出现循环依赖时,被循环依赖的bean必然还不存在于缓存,所以无法解决循环依赖.spring在bean创建完成前就将实例存入缓存.虽然此时的实例数据并不完全,但是满足基本的依赖问题,实例数据后续补充完整即可.
