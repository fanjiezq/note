# 类加载流程
## 类生命周期
1. 加载:将class文件转化为方法区的运行时数据结构,在内存中生成一个代表这个类的java.lang.Class对象(Klass对象)
2. 连接
    + 验证:确保Class文件的字节流中包含的信息符合《Java虚拟机规范》 的全部约束要求
    + 准备:为类中静态变量变量分配内存并设置类变量初始值,这里初始值是每个类型的默认值,如果变量被赋予了值,必须在初始化阶段才能生效
    + 解析:将常量池内的符号引用替换为直接引用
3. 初始化:执行类构造器<clinit>()方法,此方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块） 中的语句合并产生的.会根据程序员的编码对类的变量赋值,以及执行一些静态方法
4. 使用
5. 卸载

## 类初始化时机
1. 使用new关键字实例化对象;读取或设置的静态字段;调用静态方法
2. 使用java.lang.reflect包的方法对类型进行反射调用
3. 初始化类的时候， 如果发现其父类还没有进行过初始化， 则需要先触发其父类的初始化
4. 虚拟机启动时自动加载主类
5. 使用JDK 7新加入的动态语言支持时,如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄,并且这个方法句柄对应的类没有进行过初始化,则需要先触发其初始化
6. 一个接口中定义了JDK 8新加入的默认方法(被default关键字修饰的接口方法)时,如果有这个接口的实现类发生了初始化， 那该接口要在其之前被初始化

## 类加载器
+ java中的每个类的唯一性有两个因素决定,一是类本身是否源于同一个文件,二是类加载器是否是同一个,两者共同确定了类在jvm中的唯一性
+ jvm的类加载器有三类,BootStrap类加载器 >  扩展类加载器 > 应用类加载器，三者看似为父子关系，实际上并非简单的继承，而是使用组合方式实现的“继承”
    - BootStrap类加载器:加载<JAVA_HOME>\lib目录 下的类
    - 扩展类加载器:加载<JAVA_HOME>\lib\ext目录中的类
    - 应用类加载器:加载由程序员编写的类
+ 类加载时遵循双亲委派机制,即一个类如果可以被父类加载器加载就优先使用父类加载器。双亲委派机的好处是java的类天然带有一一种层级关系，核心类永远只能被固定的类加载器加载，保证了java体系的稳定性
+ 破坏双亲委派模型:双亲委派机制保证了java的核心类不会被用户自定义的加载器加载,降低了类管理的混乱，保证了一定安全性,但是其局限性在于不够灵活，启动类加载器和扩展类加载器只能加载对应目录的固定类，如果某些场景需要核心类加载外部类，双亲委派机制就成了阻碍。比如JDBC服务,其只提供了一系列数据库连接和管理的接口，而接口放在rt.jar包下，具体实现需要各个厂商自己实现,所以JDBC的接口应该由启动类加载器加载，但是真正使用是需要加载外部驱动，启动类加载器无能为力，所以java提供了线程上下文类加载器，打破了双亲委派机制。此外tomcat使用自定义类加载器，用户不同app的类隔离

## 方法调用与局部变量表
方法是java程序的基本调度单元,程序的运行就是方法之间的互相调用,方法调用流程很复杂,因为需要记录方法调用的数据和顺序,一般使用栈结构来保存方法的数据,栈结构的后进先出特性保证了方法调用的顺序.每个线程会维护一个局部变量表,线程中的方法每次调用其他方法,都会将本方法的数据压栈,栈顶数据永远是当前方法的数据,当前方法执行完毕后出栈,就能回到上一个方法.

# java对象的结构是怎么样的
java对象以meta-data 模型保存的，包含两部分java元数据和java本身数据,元数据就是类对象Kclass,本身数据就是保存在堆内存的Oop对象
