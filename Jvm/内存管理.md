# 内存管理
## 内存区域划分
1. 程序计数器
    + 当前线程执行字节码的行号指示器,作用是改变这个指示器的值来选取下一条需要执行的字节码指令,分支,循环,跳转,异常处理,线程恢复需要利用程序计数器
    + 程序计数器是java线程私有的,每个线程独立
2. java 虚拟机栈
    + 程序每创建一个线程，jvm都会为其分配一个虚拟机栈，我们通常所说的栈内存由所有线程得虚拟机栈组成,每个虚拟机栈的大小由-Xss参数配置决定。方法每调用一次就会形成一个栈帧，其中包含了线程的局部变量，方法出口等数据，每个方法的局部变量等数据越小，压栈时栈帧就会越小，此虚拟机栈可容纳更多栈帧，此线程的方法调用深度就越大
    + 栈内存是java线程私有的,每个线程独立
3. 本地方法栈
    + 与java 虚拟机栈作用相似,只不过是服务于java的本地方法
4. java堆
    + 虚拟机中最大一块内存,用于存放对象实例
    + 对内存被所有线程共享
    + 是垃圾收集器管理的主要区域
    + 可以是物理上不连续的空间
5. 方法区
    + 用于存储已经被加载的类信息,常量,静态变量
    + 被所有线程共享
6. 运行时常量池
    + 方法区的一部分,但是jdk8被移动到堆内存中
    + 用于存放编译期生成的各种字面量和符号引用,比如字符串
    + 一般是在类加载后保存到常量池,但是程序运行中也可能添加一些数据进入常量池,比如在运行期间使用的String.intern()声明字符串变量,新的字符串变量实际会引用常量池中原有字符串
7. 直接内存
    + 直接内存并不是jvm内存体系下的,也不归jvm管理,但是java的NIO可以使用Native函数库直接分配堆外内存， 然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作
    + 直接内存的使用能在一些场景中显著提高性能， 因为避免了在Java堆和Native堆中来回复制数据
    + 如果程序使用到了直接内存,程序运行过程中实际使用的内存空间会大于配置的空间,进行硬件申请的时候需要注意
    
## 堆内存详解
### 对象的创建
1. Java虚拟机遇到一条字节码new指令,首先在常量池检查是否存在对象引用,并检查这个符号引用代表的类是否被加载,初始化等,如果没有则加载类
2. 类加载完成后,类实例需要的内存大小已经可以确认,虚拟机会按照一定策略为实力分配一部分内存
3. 内存分配完成之后， 虚拟机必须将分配到的内存空间（但不包括对象头） 都初始化为零值,让对象不经过任何处理就可以直接使用,数据都是0值默认数据
4. 接着虚拟机将这个对象是哪个类的实例、 如何才能找到类的元数据信息等数据写入到对象头.此时从虚拟机的视角,对象已经创建完毕

# 垃圾收集器
## 判断对象已经死亡
+ 引用计数法:在对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加一;当引用失效时,计数器值就减一;任何时刻计数器为零的对象就是不可被引用的.优点是实现简单,速度快,缺点是无法解决循环引用问题
+ 可达性分析:jvm维护一组 GC Root 对象(栈中引用的对象,类静态属性引用的对象,常量引用的对象...),每个GC Root都是一个树的根节点,所有与之存在引用关系的对象会一起构成一棵树,从根节点根据引用关系向下搜索,搜索过程所走过的路径称为“引用链”,如果某个对象到GC Roots间没有任何引用链相连,或者用图论的话来说就是从GC Roots到这个对象不可达时,则证明此对象是不可能再被使用的;

## 堆内存分区和GC类型
### 内存分区
+ 新生代
    - Eden
    - Survivor1
    - Survivor2
+ 老年代
新生代和老年代瓜分堆内存，两者比例可以通过参数NewRatio调节，默认为2，即 新生代:老年代 = 1:2
新生代的三个部分默认比例时8:1:1，可以通过SurvivorRatio参数调节，不过一般默认即可

### GC分类
+ Minor GC:从年轻代空间(包括 Eden 和 Survivor 区域)回收内存被称为 Minor GC,采用标记复制算法,每次GC将Eden和其中一个Survivor 中存活的对象复制到另一个Survivor.
+ Major GC:对永久代的清理,一般虚拟机不实现
+ Full GC:清理整个堆空间—包括年轻代和永久代

## 内存分配策略
1. 大多数情况下,对象在新生代Eden区中分配,当Eden区没有足够空间进行分配时,虚拟机将发起一次Minor GC 
2. 大对象直接进入老年代,避免GC时大对象在Eden区及两个Survivor区之间来回复制,HotSpot虚拟机的XX:PretenureSizeThreshold可以设置大对象的标准值
3. 长期存活的对象将进入老年代,对象在Survivor区中每熬过一次Minor GC， 年龄就增加1岁， 当它的年龄增加到一定程度(默认为15),就会被晋升到老年代中
4. 动态对象年龄判定,HotSpot虚拟机中,如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半,年龄大于或等于该年龄的对象就可以直接进入老年代

## 垃圾收集理论依据
当前商业虚拟机的垃圾收集器， 大多数都遵循了“分代收集”（Generational Collection） [1]的理论进行设计， 分代收集名为理论， 实质是一套符合大多数程序运行实际情况的经验法则， 它建立在两个分代假说之上
1. 弱分代假说（Weak Generational Hypothesis） ： 绝大多数对象都是朝生夕灭的
2. 强分代假说（Strong Generational Hypothesis） ： 熬过越多次垃圾收集过程的对象就越难以消亡

## 垃圾收集方式分类
+ 部分收集(Partial GC):指目标不是完整收集整个Java堆的垃圾收集， 其中又分为：
    - 新生代收集(Minor GC/Young GC):指目标只是新生代的垃圾收集
    - 老年代收集(Major GC/Old GC):指目标只是老年代的垃圾收集,目前只有CMS收集器会有单独收集老年代的行为
    - 混合收集(Mixed GC):指目标是收集整个新生代以及部分老年代的垃圾收集,目前只有G1收集器会有这种行为。
+ 整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集

## 垃圾收集算法(分代收集)
1. 标记-清除算法:标记出所有需要回收的对象,在标记完成后,统一回收掉所有被标记的对象,也可以反过来.优点是实现简单;缺点是收集效率会随着对象数量变多变慢,不够稳定,且会存在大量内存碎片
2. 标记-复制算法:又称半区复制,将可用内存按容量划分为大小相等的两块,每次使用一半,当一块用完后进行内存回收,并将存活的对象复制到另一半内存区域,然后把当前内存一次清理掉.优点是运行高效,稳定;缺点是可用内存减半
3. 升级版标记-复制算法(Appel式回收):实际经验表明,每次GC存活的对象数量远远没有内存的一半,所以内存内存布局应该调整.appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间， 每次分配内存只使用Eden和其中一块Survivor.发生垃圾搜集时,将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上, 然后直接清理掉Eden和已用过的那块Survivor空间,HotSpot虚拟机默认Eden和Survivor的大小比例是8:1.当然,总是有极端情况导致GC后存货下来的对象很多,超过了一个Survivor空间,因此appel还存在一个安全设计,当Survivor空间不足以容纳一次Minor GC之后存活的对象时,多余的对象可以直接保存在老年代内存空间
4. 标记-整理算法:标记-复制算法在对象存活率较高时就要进行较多的复制操作,效率将会降低.更关键的是,如果不想浪费50%的空间,就需要有额外的空间进行分配担保,以应对被使用的内存中所有对象都100%存活的极端情况,所以在老年代一般不能直接选用这种算法.标记整理算法的步骤是先标记不需要被回收的对象,然后将对象移动到内存空间的一边.然后一次性清除边界以外的内存.常常被用于老年代的内存回收

## 经典垃圾收集器
### 新生代收集器
1. Serial收集器:采取标记复制算法,特点是但线程采集,优点是简单而高效,缺点是GC过程中所有用户线程都会停止.对于运行在客户端模式下的虚拟机来说是一个很好的选择
2. ParNew收集器:是Serial收集器的多线程版本,拥有这与之一样的优点和缺点,适合在多核服务器上使用,后来ParNew合并入CMS,成为它专门处理新生代的组成部分
3. Parallel Scavenge收集器: 使用标记复制算法,特点是专注于提升系统整体吞吐量,用户可以配置期望达到的系统吞吐量和期望的gc停顿时间, 收集器将尽力保证内存回收花费的时间不超过用户设定值.不过吞吐量和gc停顿时间是互斥的,优化其中一个必然牺牲另外一个
### 老年代收集器
1. Serial Old收集器:Serial收集器的老年代版本,采用标记整理算法
2. Parallel Old收集器:Parallel Scavenge收集器的老年代版本,基于标记整理算法,两者可以搭配,适用于注重吞吐量或者处理器资源较为稀缺的场合
3. CMS收集器:一种以获取最短回收停顿时间为目标的收集器,基于标记-清除算法,特点是并发收集,低停顿,适合注重系统响应速度的场景
4. Garbage First收集器:一款主要面向服务端应用的垃圾收集器,服务端模式下的默认垃圾收集器

### 设置垃圾收集器
+ -XX:+UseSerialGC，虚拟机在Client模式下的默认值，Serial+Serial Old
+ -XX:+UseParNewGC，ParNew+Serial Old，在JDK1.8中已经不推荐使用并且将被移除（Java HotSpot(TM) Client VM warning: Using the ParNew young collector with the Serial old collector is deprecated and will likely be removed in a future release）
+ -XX:+UseConcMarkSweepGC，ParNew+CMS+Serial Old（CMS执行失败时会切换到Serial Old）
+ -XX:+UseParallelGC ，虚拟机在Server模式下的默认值，Parallel Scavenge+Serial Old
+ -XX:+UseParallelOldGC ，Parallel Scavenge+Parallel Old
+ -XX:+UseG1GC，G1 Young Generation+G1 Old Generation

# 类加载流程
## 类生命周期
1. 加载:将class文件转化为方法区的运行时数据结构,在内存中生成一个代表这个类的java.lang.Class对象
2. 连接
    + 验证:确保Class文件的字节流中包含的信息符合《Java虚拟机规范》 的全部约束要求
    + 准备:为类中静态变量变量分配内存并设置类变量初始值,这里初始值是每个类型的默认值,如果变量被赋予了值,必须在初始化阶段才能生效
    + 解析:将常量池内的符号引用替换为直接引用
3. 初始化:执行类构造器<clinit>()方法,此方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块） 中的语句合并产生的.会根据程序员的编码对类的变量赋值,以及执行一些静态方法
4. 使用
5. 卸载

## 类初始化时机
1. 使用new关键字实例化对象;读取或设置的静态字段;调用静态方法
2. 使用java.lang.reflect包的方法对类型进行反射调用
3. 初始化类的时候， 如果发现其父类还没有进行过初始化， 则需要先触发其父类的初始化
4. 虚拟机启动时自动加载主类
5. 使用JDK 7新加入的动态语言支持时,如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄,并且这个方法句柄对应的类没有进行过初始化,则需要先触发其初始化
6. 一个接口中定义了JDK 8新加入的默认方法(被default关键字修饰的接口方法)时,如果有这个接口的实现类发生了初始化， 那该接口要在其之前被初始化

## 类加载器
+ java中的每个类的唯一性有两个因素决定,一是类本身是否源于同一个文件,二是类加载器是否是同一个
+ jvm的类加载器有三类,BootStrap类加载器 >  扩展类加载器 > 应用类加载器
    - BootStrap类加载器:加载<JAVA_HOME>\lib目录 下的类
    - 扩展类加载器:加载<JAVA_HOME>\lib\ext目录中的类
    - 应用类加载器:加载由程序员编写的类
+ 类加载时遵循双亲委派机制,即一个类如果可以被父类加载器加载就优先使用父类加载器
+ 破坏双亲委派模型, 双亲委派机制保证了java的核心类不会被用户自定义的加载器加载,保证了一定安全性,但是有些情况也存在一些问题,比如核心类需要调用外部的类,比如JNDI服务,其提供的接口本身就需要各个厂商自己实现,如果强制使用双亲委派机制,jndi服务将无法使用,所以java提供线程上下文类加载器 来绕过双亲委派机制

## 方法调用与局部变量表
方法是java程序的基本调度单元,程序的运行就是方法之间的互相调用,方法调用流程很复杂,因为需要记录方法调用的数据和顺序,一般使用栈结构来保存方法的数据,栈结构的后进先出特性保证了方法调用的顺序.每个线程会维护一个局部变量表,线程中的方法每次调用其他方法,都会将本方法的数据压栈,栈顶数据永远是当前方法的数据,当前方法执行完毕后出栈,就能回到上一个方法.
