# java内存模型JMM
+ 从硬件层面看，数据必须存在于内存才可以被cpu计算，但是实际上cpu也并不是直接操作内存上的数据，而是直接操作寄存器的数据，寄存器下有高速缓存，再往下才是内存。而且随着计算机的不断演进，这一架构也可能不断变动，为了屏蔽这种差异，java自己定义了一个内存模型JMM
+ JMM将内存分为主内存和工作内存,主内存属于公共内存,被线程共享，所有变量都需要保存在主内存;工作内存是每个线程独有的，所有变量只能在工作内存中修改
+ JMM并不是真的内存划分，而是一种内存访问规则，JMM规定了java程序的各种变量(静态变了，实例变量，方法本地变量)如何访问，如何修改，但是并没有实际的内存划分。JVM内存划分就是围绕这一规范实际对JVM的内存区域进行实际的划分

# JVM内存划分
1. 程序计数器
    + 当前线程执行字节码的行号指示器,作用是改变这个指示器的值来选取下一条需要执行的字节码指令,分支,循环,跳转,异常处理,线程恢复需要利用程序计数器
    + 程序计数器是java线程私有的,每个线程独立
2. java 虚拟机栈
    + 程序每创建一个线程，jvm都会为其分配一个虚拟机栈，我们通常所说的栈内存由所有线程得虚拟机栈组成,每个虚拟机栈的大小由-Xss参数配置决定。方法每调用一次就会形成一个栈帧，其中包含了线程的局部变量，方法出口等数据，每个方法的局部变量等数据越小，压栈时栈帧就会越小，此虚拟机栈可容纳更多栈帧，此线程的方法调用深度就越大
    + 栈内存是java线程私有的,每个线程独立.栈内存与堆内存占用了jvm内存的大部分，物理机的内存是有限的，栈分配的内存多，堆分配的内存就少
3. 本地方法栈
    + 与java 虚拟机栈作用相似,只不过是服务于java的本地方法
4. java堆
    + 虚拟机中最大一块内存,用于存放对象实例
    + 对内存被所有线程共享
    + 是垃圾收集器管理的主要区域
    + 可以是物理上不连续的空间
5. 方法区
    + 用于存储已经被加载的类信息,常量,静态变量
    + 被所有线程共享
6. 运行时常量池
    + 方法区的一部分,但是jdk8被移动到堆内存中
    + 用于存放编译期生成的各种字面量和符号引用,比如字符串
    + 一般是在类加载后保存到常量池,但是程序运行中也可能添加一些数据进入常量池,比如在运行期间使用的String.intern()声明字符串变量,新的字符串变量实际会引用常量池中原有字符串
7. 直接内存
    + 直接内存并不是jvm内存体系下的,也不归jvm管理,但是java的NIO可以使用Native函数库直接分配堆外内存， 然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作
    + 直接内存的使用能在一些场景中显著提高性能， 因为避免了在Java堆和Native堆中来回复制数据
    + 如果程序使用到了直接内存,程序运行过程中实际使用的内存空间会大于配置的空间,进行硬件申请的时候需要注意
8. 方法区 VS 永久代 VS Metaspace
    + JVM虚拟机规范中包含一个方法区，存储类信息，静态变量等等。在jdk7之前，方法区的实现与其他区域隔离开，是一块单独的区域。jdk7中 HotSpot虚拟机调整了方法区的实现，概念上还是方法区但是物理上，方法区和堆内存放在一起，加在老年代后面，被称为永久代。这样实现的好处是方法区的内存也可以跟随老年代一起被回收。jdk8 HotSpot虚拟机又调整了方法区的实现，将其放在本地内存，称呼也由永久代变为元空间，至此永久代概念成为历史。总的来说，不论是早期的隔离的方法区，还是永久代还是元空间，都是jvm虚拟机方法区规范的实现，只是实现方式不同
    
## 堆内存详解
### 对象的创建
1. Java虚拟机遇到一条字节码new指令,首先在常量池检查对应的类是否被加载,初始化等,如果没有则加载类
2. 类加载完成后,类实例需要的内存大小已经可以确认,虚拟机会按照一定策略为实力分配一部分内存
3. 内存分配完成之后， 虚拟机必须将分配到的内存空间（但不包括对象头） 都初始化为零值,让对象不经过任何处理就可以直接使用,数据都是0值默认数据
4. 接着虚拟机将这个对象是哪个类的实例、 如何才能找到类的元数据信息等数据写入到对象头.此时从虚拟机的视角,对象已经创建完毕

# 垃圾收集器
## 判断对象已经死亡
+ 引用计数法:在对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加一;当引用失效时,计数器值就减一;任何时刻计数器为零的对象就是不可被引用的.优点是实现简单,速度快,缺点是无法解决循环引用问题
+ 可达性分析:jvm维护一组 GC Root 对象(栈中引用的对象,类静态属性引用的对象,常量引用的对象...),每个GC Root都是一个树的根节点,所有与之存在引用关系的对象会一起构成一棵树,从根节点根据引用关系向下搜索,搜索过程所走过的路径称为“引用链”,如果某个对象到GC Roots间没有任何引用链相连,或者用图论的话来说就是从GC Roots到这个对象不可达时,则证明此对象是不可能再被使用的;

## 堆内存分区和GC类型
### 内存分区
+ 新生代
    - Eden
    - Survivor1
    - Survivor2
+ 老年代
    - 新生代和老年代瓜分堆内存，两者比例可以通过参数NewRatio调节，默认为2，即 新生代:老年代 = 1:2
    - 新生代的三个部分默认比例时8:1:1，可以通过SurvivorRatio参数调节，不过一般默认即可

### GC分类
+ Minor GC:从年轻代空间(包括 Eden 和 Survivor 区域)回收内存被称为 Minor GC,采用标记复制算法,每次GC将Eden和其中一个Survivor 中存活的对象复制到另一个Survivor.
+ Major GC:对永久代的清理,一般虚拟机不实现
+ Full GC:清理整个堆空间—包括年轻代和永久代，触发Full GC有以下几种情况，1）老年代内存不足(新生代对象升级或者保存大对象) 2）方法区内存不足 3) 老年区无法进行内存担保时 4）Minor GC 发现存活的对象内存大小大于老年代内存大小

## 内存分配策略
1. 大多数情况下,对象在新生代Eden区中分配,当Eden区没有足够空间进行分配时,虚拟机将发起一次Minor GC 
2. 大对象直接进入老年代,避免GC时大对象在Eden区及两个Survivor区之间来回复制,HotSpot虚拟机的XX:PretenureSizeThreshold可以设置大对象的标准值
3. 长期存活的对象将进入老年代,对象在Survivor区中每熬过一次Minor GC， 年龄就增加1岁， 当它的年龄增加到一定程度(默认为15),就会被晋升到老年代中
4. 动态对象年龄判定,HotSpot虚拟机中,如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半,年龄大于或等于该年龄的对象就可以直接进入老年代

## 垃圾收集理论依据
当前商业虚拟机的垃圾收集器， 大多数都遵循了“分代收集” 的理论进行设计， 分代收集名为理论， 实质是一套符合大多数程序运行实际情况的经验法则， 它建立在两个分代假说之上
1. 弱分代假说（Weak Generational Hypothesis） ： 绝大多数对象都是朝生夕灭的
2. 强分代假说（Strong Generational Hypothesis） ： 熬过越多次垃圾收集过程的对象就越难以消亡

## 垃圾收集算法(分代收集)
1. 标记-清除算法:标记出所有需要回收的对象,在标记完成后,统一回收掉所有被标记的对象,也可以反过来.优点是实现简单;缺点是收集效率会随着对象数量变多变慢,不够稳定,且会存在大量内存碎片
2. 标记-复制算法:又称半区复制,将可用内存按容量划分为大小相等的两块,每次使用一半,当一块用完后进行内存回收,并将存活的对象复制到另一半内存区域,然后把当前内存一次清理掉.优点是运行高效,稳定;缺点是可用内存减半
3. 升级版标记-复制算法(Appel式回收):实际经验表明,每次GC存活的对象数量远远没有内存的一半,所以内存内存布局应该调整.appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间， 每次分配内存只使用Eden和其中一块Survivor.发生垃圾搜集时,将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上, 然后直接清理掉Eden和已用过的那块Survivor空间,HotSpot虚拟机默认Eden和Survivor的大小比例是8:1.当然,总是有极端情况导致GC后存货下来的对象很多,超过了一个Survivor空间,因此appel还存在一个安全设计,当Survivor空间不足以容纳一次Minor GC之后存活的对象时,多余的对象可以直接保存在老年代内存空间
4. 标记-整理算法:标记-复制算法在对象存活率较高时就要进行较多的复制操作,效率将会降低.更关键的是,如果不想浪费50%的空间,就需要有额外的空间进行分配担保,以应对被使用的内存中所有对象都100%存活的极端情况,所以在老年代一般不能直接选用这种算法.标记整理算法的步骤是先标记不需要被回收的对象,然后将对象移动到内存空间的一边.然后一次性清除边界以外的内存.常常被用于老年代的内存回收

## GC 过程
1. 对象被创建一般直接被分配在到新生代(数组这种大对象可能直接被分配到老年代)，当新生代内存不足就可能触发Minor GC
2. 如果老年代没有足够的空间就会触发一次Full GC，此外在 Minor GC 前系统会检查老年代剩余内存是否大于新生代所有对象总大小，如果小于，且不允许内存担保失败，也会进行Full GC
3. GC回收内存时一般采用可达性分析算法来判断对象是否可以回收，其基本思想是用一些特殊对象作为起点(GC Root),然后根据引用关系形成图，如果某个对象和任何GC Root 之间都没有直接和间接的引用关系，这个对象“不可达”，说明这个对象已经没有被使用，可以回收
4. 对象被识别为"不可达"后没有被马上清理，还要经过两次标记过程，第一次标记判断此对象是否需要执行finalize()方法。如果需要执行则对象被加入到一个特殊队列，这个队列中的对象会进行第二次标记，执行finalize()方法，如果在finalize()方法中对象自救，将其引用加入任何一个GC Root图，对象就不会被回收。但是 finalize() 执行是不确定的，尽量避免使用
5. 新生代一般采用标记复制算法，因为新生代对象经常朝生夕死，长期存活的对象很少，应对这种情况标记-复制算法比较简单高效。老年代一般使用标记-清除或标记-整理算法，因为老年代对象很少被回收，采用复制算法成本太高，标记-清除算法速度最快但是会存在内存碎片，标记-整理算法没有内存碎片，但是成本高昂。不同的垃圾收集器可能采用不同的算法
6. 垃圾回收时会在程序中设置一个安全点，所有线程到达安全点后会暂停执行，等到垃圾回收完成后再开始执行

## 经典垃圾收集器
### 新生代收集器
1. Serial收集器:采取标记复制算法,特点是但线程采集,优点是简单而高效,缺点是GC过程中所有用户线程都会停止.对于运行在客户端模式下的虚拟机来说是一个很好的选择
2. ParNew收集器:是Serial收集器的多线程版本,拥有这与之一样的优点和缺点,适合在多核服务器上使用,后来ParNew合并入CMS,成为它专门处理新生代的组成部分
3. Parallel Scavenge收集器: 使用标记复制算法,特点是专注于提升系统整体吞吐量,用户可以配置期望达到的系统吞吐量和期望的gc停顿时间, 收集器将尽力保证内存回收花费的时间不超过用户设定值.不过吞吐量和gc停顿时间是互斥的,优化其中一个必然牺牲另外一个
### 老年代收集器
1. Serial Old收集器:Serial收集器的老年代版本,采用标记整理算法
2. Parallel Old收集器:Parallel Scavenge收集器的老年代版本,基于标记整理算法,两者可以搭配,适用于注重吞吐量或者处理器资源较为稀缺的场合
3. CMS收集器:一种以获取最短回收停顿时间为目标的收集器,基于标记-清除算法,特点是并发收集,低停顿,适合注重系统响应速度的场景
4. Garbage First收集器:一款主要面向服务端应用的垃圾收集器,服务端模式下的默认垃圾收集器

### 设置垃圾收集器
+ -XX:+UseSerialGC，虚拟机在Client模式下的默认值，Serial+Serial Old
+ -XX:+UseParNewGC，ParNew+Serial Old，在JDK1.8中已经不推荐使用并且将被移除（Java HotSpot(TM) Client VM warning: Using the ParNew young collector with the Serial old collector is deprecated and will likely be removed in a future release）
+ -XX:+UseConcMarkSweepGC，ParNew+CMS+Serial Old（CMS执行失败时会切换到Serial Old）
+ -XX:+UseParallelGC ，虚拟机在Server模式下的默认值，Parallel Scavenge+Serial Old
+ -XX:+UseParallelOldGC ，Parallel Scavenge+Parallel Old
+ -XX:+UseG1GC，G1 Young Generation+G1 Old Generation
