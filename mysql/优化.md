# 查询语句优化
1. 使用索引
2. 语句中存在计算时尽量只计算一次
3. 查询中如果存在大字段,使用子查询先查询出id,然后再查询出最终结果

# 优化技巧
1. 善用 explain 分析执行计划


# 查询语句优化
## 查询值优化
1. 每个语句只查询真正需要的值,切忌使用*
2. 如果查询值中存在大字段,需要使用子查询先查询出对应Id,然后最后定位到最终的记录
3. limit语句在比较大的表上性能比较差,特别是偏移量很大的时候,比如limit 10000,10 可以使用select * from table where id < 10010 order by id desc limit 10;代替


## 索引优化技巧
### 单列索引
 1. 如果索引比较长,可以截取前面的部分字段进行匹配
 2. 如果使用innoDB引擎, 一般情况下应该使用一个自增Id作为主键,因为聚簇索引的数据存储形式,B+Tree的数据结构限制,乱序插入的数据在磁盘中存储位置也是混乱的,还会导致大量的页分裂.则会导致表数据聚集性大幅降低,磁盘的使用效率也会下降(参考:https://zhuanlan.zhihu.com/p/98818611)
 3. 自增主键也不是实时都好,在插入操作并发量很大的情况下,自增主键会成为性能瓶颈,因为主键的自增必须是原子的,大量并发请求会导致锁竞争
 4. show index from table;的返回值中包含一个Cardinality字段,表示添加索引中唯一数据的条数(抽样估计值).因为索引对于那种唯一行比较高的数据效果才更好,所以此值与表的数据总量比值越接近1,则索引效果越好,否则就需要考虑是否删除这个索引

### 多列索引
 1. 时刻记住最左前缀匹配,最大程度使用索引 
 2. 使用时如果给定的值类型与索引列值类型不对应,无法有效的使用索引
 3. 如果多个条件中存在范围查找,该条件往后的部分不会走索引
 4. 多列索引在匹配时是按照索引列的顺序匹配,索引第一个字段相同会比较第二个字段,如果不考虑排序和分组,建立索引时将过滤效果最好的索引放在最前面
 5. 如果经常需要排序查询,索引的顺序和排序条件的顺序应该一致,比如查询经常需要按照 年 > 月 > 日 排序,但是表中年月日是分开存储的,建立索引就应该按照这个顺序建立
 6. 创建索引时将表中经常可能会被范围查询的列放在最后一个字段,以便优化器使用更多的索引列

### HASH索引
 1. 没有顺序要求的列可以使用hash索引,因为HASH算法是随机的,HASH索引也无法用于排序
 2. 如果列值A比较长,却希望使用hash索引,可以在表中保存一个冗余的hash列B,值就是A的hash值,查询时使用 select * from A = X and B = hash(X),效率非常高,因为B的值很短.之所以使用两个组合.是因为hash函数可能发生碰撞,此时需要  A = X 条件进行最终的选择


## 排序优化
1. 当索引包含了所有的查询字段,order by会使用索引排序(explain的type为index)
2. 联表查询,只有order by 语句使用的条件都是第一个表的索引列,才会走索引排序

## 范围查询优化
1. 查询使用联合索引,某一索引列使用了范围查询条件,此列往后的列无法再使用索引


## 分区表
当单个表的数据量超大时,索引带来的正面效果将大幅度下降,甚至带来反面效果,原因如下
+ 只要不是索引覆盖扫描,数据引擎需要进行IO操作将索引匹配的记录查询到内存,数据量超大时大量的随机IO操作使得查询速度无法忍受
+ 数据量太大,索引的维护成本变得非常高,插入和删除操作速度会很慢
+ 索引的数据量本身会变得很大,内存吃紧
+ 大表存在热点数据时,热点数据查询速度得不到保证

因为以上原因,超大数据量的表需要进行拆分,方法是使用分区表,分区表的原理是根据数据的特征(比如时间)将数据分区域存放,查询时很多时候也可以分区区域查询,查询一个分区的数据就好像查询一个小的子表

### 分区表的优点
+ 使用分区表以后一般不用建立索引(考虑扩展性,也不应该添加索引),减少了索引本身带来的问题
+ 分的区表可以很好的处理热点数据,就是将热点数据划分在一个分区
+ 使用分区表,很多查询不必遍历全部数据,使得一些因为时间太长不可能实现的查询成为可能

### 分区表的问题
+ NULL 值使分区过滤无效,分区表的第一个分区是存储分区条件为NULL的,所有分区条件为NULL的记录都会存储在这个分区,而每次查询时,数据引擎都会检查这个分区的数据,所以如果这个分区太大,就会导致所有的查询都很慢
+ 分区列和索引列不是匹配的时候查询效率会很慢,因为分区表的每个分区的索引是独立的.分区列与索引列不匹配就会导致查询时每个分区的索引都会被扫描
+ 确定某个记录在哪个分区的查询随着分区的增多,性能会变差
+ 分区表增删改查操作,数据引擎都会锁住所有的分区,然后根据条件过滤掉不用的分区,并释放这一部分分区的锁,但是并发量比较大时,这里依然会成为性能瓶颈

## join优化
# 笛卡尔积
{a,b} X {1,2,3} =  {(a,1),(b,1),(a,2),(b,2),(a,3),(b3)}

### 联表
联表查询的本质是将多个表以笛卡尔积的方式合并为一个虚拟表,然后在虚拟表的基础上进行筛选

表A
a1|a2
-|-|
a|aa
b|bb
---
表B
b1|b2
-|-|
1|11
2|22
3|33
---
查询语句 select A.*,B.* from A,B; 得到:

a1|a2|b1|b2
-|-|-|-
a|aa|1|11
a|aa|2|22
b|bb|1|11
b|bb|2|22

表的每一行作为笛卡尔积的一个元素,由此联接成为一个新表,也可以用伪代码表示为

    List result = new List();
    for(a in A){
        for(b in B){
            result.add(<a,b>)
        }
    }

### 联表过滤条件 where on
on 语句在生成虚拟表时生效,on 条件可以有效的减小虚拟表的大小
where 条件在过滤虚拟表的数据时生效

    1)select a.*,b.* from a,b where a.id = b.id and a.id = 1
    2)select a.*,b.* from a inner join b on a.id = b.id and a.id = 1
    3)select a.*,b.* from a inner join b on a.id = b.id where a.id = 1
以上三条语句获取的结果一样,使用的索引的情况也一样,但是差别在于 1 的中间表比 2 大
所以一般联表查询最好使用 2 或 3 的格式,可以节省内存

需要注意的是,在left join中,on语句后的条件对左表是没有作用的,但是where条件对左表有作用,right join则相反


### Nested Loop Join 算法 VS Block Nested-Loop Join 算法
+ mysql联表查询的中间表的生成算法(构建笛卡尔积的算法)是Nested Loop Join算法,这种算法使用双层循环实现.外层循环的每一个值与内层循环的值进行比较,构建出中间表.外层循环的表被成为驱动表,内层循环的表被成为被驱动表
+ 外层循环的每一个值必然会遍历到,内层循环则不然,因为索引的存在,内存循环的比较可以走索引,这可能大大缩减内层循环的比较次数,所以查询优化的重点在于两点,一是保证内内层循环用到索引,二是保证外层循环尽可能少
+ 理论上任何时候都应该使用记录数少的表作为驱动表,mysql在执行查询语句时判断驱动表的标准有两条
    - 当连接查询没有where条件时，左连接查询时，前面的表是驱动表，后面的表是被驱动表，右连接查询时相反，内连接查询时，哪张表的数据较少，哪张表就是驱动表
    - 当连接查询有where条件时，带where条件的表是驱动表，否则是被驱动表
+ 如果被驱动表连接条件没有索引覆盖，性能会很低，此时mysql会选择使用 Block Nested-Loop Join 算法，将被驱动表数据加载到内存中比较，加快速度。Nested Loop Join是磁盘扫描，但是在有索引情况下Nested Loop Join性能更高

Nested Loop Join 算法伪代码如下:

    List result = new List();
    for(a in A){ //驱动表
        for(b in B){ //被驱动表
            result.add(<a,b>)
        }
    }

参考:
https://www.cnblogs.com/sy270321/p/12760211.html
https://zhuanlan.zhihu.com/p/81398139


# 数据库连接池常用配置参数
1. initialSize 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时
2. maxActive 最大连接池数量
3. minIdle 最小连接池数量
4. maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。
5. validationQuery 用来检测连接是否有效的sql，要求是一个查询语句