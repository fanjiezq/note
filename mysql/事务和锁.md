# 锁分类
+ 思想上划分
    - 悲观锁:事物开始前假设一定会存在竞争情况, 所以在事物开始前就加锁,保证安全
    - 乐观锁:事物开始前假设不会存在竞争情况, 发生数据不一致的时候进行回滚重试

+ 按照锁的粒度划分(https://juejin.cn/post/6970520995283075108)
    - 行锁:只锁住事务相关的行,优点是锁住的数据范围小,可以提高并发.缺点是加锁成本高，InnoDB实现了行锁，但是是基于索引的，非索引查询还是表锁
    - 表锁:直接锁住事务涉及到的表, 优点是加锁简单开销低,缺点是很容易出现资源竞争
    - 页锁:对事物涉及到的数据页进行加锁,加锁开销和并发性介于行锁和表锁之间
    - 间隙锁:范围查询时innodb会对涉及到的数据范围加锁,防止幻读的产生
    - Next-key锁: 行锁和间隙锁结合的一种锁，在repeatable read 级别下才有，是mysql优先使用的锁，行锁和间隙锁都是Next-key锁在特定条件下退化而来的，比如针对唯一索引的查询，如果数据存在，就会退化为行锁。

+ 按照锁的使用方式划分
    - 共享锁:事务A获取到记录T的共享锁后,事务B也可以获取T的共享锁,但是事务B不可以获取T的排他锁,可以保证读取的高并发.使用方式 LOCK TABLE table_name READ 或者 SELECT ... LOCK IN SHARE MODE 
    - 排他锁:事务A获取到记录T的排他锁后,事务B不可以获取T的任何锁,保证数据的安全性(悲观锁),使用方式 LOCK TABLE table_name WRITE 或者 SELECT ... FOR UPDATE
    - 意向锁:表锁和行所范围不同,可能存在冲突,当事务需要加表锁时,需要先扫描该表中是否已经存在排他行锁,这样效率太低,所以事务加行所时就在表上先加上意向锁,表明此表中已经存在行锁.与行锁对应,意向锁也分为共享意向锁和排他意向锁

+ 注意
    - 每个存储引擎实现的锁的类型和粒度不相同,innodb存储引擎实现了行锁和表锁,默认使用行锁,当事物有特殊需要则自动升级为表锁
    - 行锁是针对索引加锁,如果一个查询没有用到索引,则会对整个表加锁
    - 两个(或以上)的Session加锁的顺序不一致时可能发生死锁，发生死锁以后两个事务都会立即报错回滚。使用show engine innodb status 可以查看死锁日志

# 事务隔离级别
## read uncommited --可读未提交
没有任何事务保障,极易出错，但是速度快，除非库为只读库,否则不会使用.但是在此级别下,一条记录被事务A更新且没有提交,事务B不可以更新
## read committed --可读已提交
事物只能读取其他事务已经提交的数据,解决脏读(事务A读取了事务B未提交的数据,然后事务B失败回滚,事物A拿到错的数据进行操作)
## repeatable read --可重复读
一个事务中进行两次或多次同样的对于数据内容的查询，得到的结果是一样的，只要存在读该行数据就禁止写.解决不可重复读(事务A在整个事物期间两次读取同一个记录,返回值却不同,即其他事物在事物A运行期间修改了记录).但是不可防止幻读(事务A在事务期间两次查询相同的数据，返回的记录条数不一样,这种类型的幻读在mysql中使用mvcc解决了，因为读取是快照读，但是当前读类型的幻读没有解决)
## serializable --序列化读
所有事务排队的方式执行,解决幻读(使用update修改数据，可能第一次修改成功，第二次无效，有其他事物在事物A运行期间删除数据).解决幻读除了设置serializable隔离级别，还可以在度语句上加上for update，开启互斥锁

# 查询和设置mysql的事务隔离级别
Mysql支持对全局设置事物隔离级别也可以针对回话设置事物隔离级别  
+ select @@session.tx_isolation;(mysql8:select @@session.transaction_isolation)
+ set session transaction isolation level read uncommitted;

# 事务隔离级别 和 锁的关系
+ 事务隔离级别就是依赖锁机制实现的，不同的隔离级别就是不同锁组合应用产生的效果的体现

参考:https://juejin.cn/post/6878884451162521613


# MVCC(Multi-Version Concurrency Control)技术
+ 在多个事务并发过程中,数据安全问题只会出现在 进行读写和写写操作 ,解决的方式最简单的就是加锁,但是加锁对性能的损耗是很大的，为了提升读写性能，mysql使用MVCC技术以不加锁的方式解决读写情景下的数据安全问题。
+ MVCC 可以解决读写场景下的数据安全问题，无法解决写写场景下的数据安全。那么可以 MVCC + 锁的方式解决写写场景下的数据安全，至于使用乐观锁还是悲观锁，看各家实现

## MVCC利用三种技术实现:Read View(读视图)，快照读,版本链
+ Read View(读视图):每创建一个新事务的时候，innodb为当前事务创建一个读视图，这个视图保存了与当前事务相关的数据状态，这个状态是不可修改且只与当前事务有关，可以应对多个事务的读操作
+ 快照读: mysql读取数据有两种方式,当前读和快照读, insert,update,delete,select for update等等语句执行时数据会被自动加上排他锁,所以读取的数据就是当前系统最新的数据,称作当前读.单纯的select语句读取数据并没有排他锁,在读取过程中,可能有其他事物修改了数据,所以读取的只是数据的备份,被成称作快照读。读视图保存的是系统数据的历史版本，所以只适用于快照读
+ 版本链: 读视图的实现依赖存储引擎对数据历史版本的记录，这就是版本链。版本链是使用undo日志实现的，每条记录在更新的时候都会undo日志里面记录一条回滚操作，记录上的值随时可以根据这些回滚操作还原到前一个状态值，其他在事务进行数据读取时，只需要根据版本链将当前数据回滚到对应的历史值，形成一个读视图就可以实现快照读。具体实现:我们数据库中的每行数据，除了我们肉眼看见的数据，还有几个隐藏字段,关键字段是db_trx_id、db_roll_pointer
  - db_trx_id:记录创建这条记录/最后一次修改该记录的事务ID
  - db_roll_pointer（版本链关键）:7byte，回滚指针，指向这条记录的上一个版本

## MVCC实现方式
1. 事务进行快照读操作的时候生产的读视图(Read View),Read View记录了以下四个属性
    + trx_ids: 当前系统活跃(未提交)事务版本号集合。
    + up_limit_id: 创建当前read view 时“当前系统最大事务版本号+1”。
    + low_limit_id: 创建当前read view 时“系统正处于活跃事务最小版本号”
    + creator_trx_id: 创建当前read view的事务版本号
2. 设该行的当前事务id为 trx_id_0
3. 如果trx_id_0 < low_limit_id 的话，那么表明该行记录所在的事务已经在本次新事务创建之前就提交了，所以该行记录的当前值是可见的,跳到步骤6.
4. 如果trx_id_0> up_limit_id的话，那么表明该行记录所在的事务在本次新事务创建之后才开启，所以该行记录的当前值不可见,跳到步骤6。
5. 如果low_limit_id <=trx_id_0<= up_limit_id, 那么表明该行记录所在事务在本次新事务创建的时候处于活动状态，则遍历trx_ids,如果没找到匹配的记录,说明事务已经提交,返回数据.如果找到,说明事物还未提交,跳到步骤6.
6. 从该行记录的DB_ROLL_PTR指针所指向的回滚段中取出最新的undo-log的版本号，将它赋值该trx_id_0，然后跳到步骤3.
7. 将该可见行的值返回


参考:
https://juejin.cn/post/6871046354018238472
https://www.jianshu.com/p/fd51cb8dc03b