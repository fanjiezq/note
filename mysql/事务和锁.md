# 事务隔离级别
## read uncommited --读未提交
没有任何事务保障,极易出错，但是速度快，除非库为只读库,否则不会使用.但是在此级别下,一条记录被事务A更新且没有提交,事务B不可以更新
## read committed --读已提交
事物只能读取其他事务已经提交的数据,解决脏读(事务A读取了事务B未提交的数据,然后事务B失败回滚,事物A拿到错的数据进行操作)
## repeatable read --可重复读
一个事务中进行两次或多次同样的对于数据内容的查询，得到的结果是一样的，只要存在读改行数据就禁止写.解决不可重复读(:事务A在整个事物期间两次读取同一个记录,返回值却不同,即其他事物在事物A运行期间修改了记录).但不保证对于数据条数的查询是一样的
## serializable --序列化读
所有事务排队的方式执行,解决幻读:事务A在事务期间两次使用(select * from table where age = 1)查询数据,第一次查询出5条数据,第二次查询出6条数据,即,有其他事物在事物A运行期间新增或删除数据)

# 查询和设置mysql的事务隔离级别
+ select @@session.tx_isolation;(mysql8:select @@session.transaction_isolation)
+ set session transaction isolation level read uncommitted;

# 锁分类
+ 思想上划分
    - 悲观锁:事物开始前假设一定会存在竞争情况, 所以在事物开始前就加锁,保证安全
    - 乐观锁:事物开始前假设不会存在竞争情况, 发生数据不一致的时候进行回滚重试

+ 按照锁的粒度划分
    - 行锁:只锁住事务相关的行,优点是锁住的数据范围小,可以提高并发.缺点是加锁成本高
    - 表锁:直接锁住事务涉及到的表, 优点是加锁简单开销低,缺点是很容易出现资源竞争
    - 页锁:对事物涉及到的数据页进行加锁,加锁开销和并发性介于行锁和表锁之间
    - 间隙锁:范围查询时innodb会对涉及到的数据范围加锁,防止幻读的产生

+ 按照锁的使用方式划分
    - 共享锁:事务A获取到记录T的共享锁后,事务B也可以获取T的共享锁,但是事务B不可以获取T的排他锁,可以保证读取的高并发.使用方式 select * from  table lock in share mode;
    - 排他锁:事务A获取到记录T的排他锁后,事务B不可以获取T的任何锁,保证数据的安全性(悲观锁),使用方式 select * from table for update;
    - 意向锁:表锁和行所范围不同,但是可能存在冲突,当事务需要加表锁时,需要先扫描该表中是否已经存在排他行锁,这样效率太低,所以事务加行所时就在表上先加上意向锁,表明此表中已经存在行锁.与行锁对应,意向锁也分为共享意向锁和排他意向锁

+ 注意
    - 每个存储引擎实现的锁的类型和粒度不相同,innodb存储引擎实现了行锁和表锁,默认使用行锁,当事物有特殊需要则自动升级为表锁
    - 行锁是针对索引加锁,如果一个查询没有用到索引,则会对整个表加锁

参考:https://juejin.cn/post/6878884451162521613


# MVCC(Multi-Version Concurrency Control)技术
在多个事务并发过程中,数据安全问题只会出现在 进行读写和写写操作 ,解决的方式最简单的就是加锁,但是加锁对性能的损耗是很大的
MVCC技术可以一不加锁的方式解决读写情景下的数据安全问题,但是无法解决写写情景下的更新丢失问题,于是:
+ MVCC + 悲观锁：MVCC解决读写冲突，悲观锁解决写写冲突
+ MVCC + 乐观锁：MVCC解决读写冲突，乐观锁解决写写冲突

MVCC利用三种技术实现:快照读,版本链,undo日志,Read View(读视图)

+ 快照读: mysql读取数据有两种方式,当前读和快照读, insert,update,delete,select for update等等语句执行时数据会被自动加上排他锁,所以读取的数据就是当前系统最新的数据,称作当前读.单纯的select语句读取数据并没有排他锁,在读取过程中,可能有其他事物修改了数据,所以读取的只是数据的备份,被成称作快照读
+ 版本链: 我们数据库中的每行数据，除了我们肉眼看见的数据，还有几个隐藏字段,关键字段是db_trx_id、db_roll_pointer
  - db_trx_id:6byte，最近修改(修改/插入)事务没ID：记录创建这条记录/最后一次修改该记录的事务ID
  - db_roll_pointer（版本链关键）:7byte，回滚指针，指向这条记录的上一个版本

+ undo日志: Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log里。当事务进行回滚时可以通过undo log 里的日志进行数据还原
+ Read View(读视图):创建一个新事务的时候，innodb会将当前系统中的活跃事务(未提交)列表创建一个副本（read view），副本中保存的是系统当前不应该被本事务看到的其他事务id列表

MVCC实现方式
1. 事务进行快照读操作的时候生产的读视图(Read View),Read View记录了以下四个属性
    + trx_ids: 当前系统活跃(未提交)事务版本号集合。
    + up_limit_id: 创建当前read view 时“当前系统最大事务版本号+1”。
    + low_limit_id: 创建当前read view 时“系统正处于活跃事务最小版本号”
    + creator_trx_id: 创建当前read view的事务版本号
2. 设该行的当前事务id为 trx_id_0
3. 如果trx_id_0 < low_limit_id 的话，那么表明该行记录所在的事务已经在本次新事务创建之前就提交了，所以该行记录的当前值是可见的,跳到步骤6.
4. 如果trx_id_0> up_limit_id的话，那么表明该行记录所在的事务在本次新事务创建之后才开启，所以该行记录的当前值不可见,跳到步骤6。
5. 如果low_limit_id <=trx_id_0<= up_limit_id, 那么表明该行记录所在事务在本次新事务创建的时候处于活动状态，则遍历trx_ids,如果没找到匹配的记录,说明事务已经提交,返回数据.如果找到,说明事物还未提交,跳到步骤6.
6. 从该行记录的DB_ROLL_PTR指针所指向的回滚段中取出最新的undo-log的版本号，将它赋值该trx_id_0，然后跳到步骤3.
7. 将该可见行的值返回

参考:

https://juejin.cn/post/6871046354018238472

https://www.jianshu.com/p/fd51cb8dc03b