## 基本架构
+ innoDB存储引擎采用多线程模型,启动后包含诸多后台进程合作完成数据处理任务, 主要包括如下:
 - Master Thread: 负责将缓冲池数据一部刷新到磁盘,保证数据的一致性
 - IO Thread:InnoDB采用大量AIO,此线程负责处理后台的异步回调
 - Purge Thread:负责回收已经无用的UNDO页
 - Page Cleaner Thread:负责将脏页数据刷新到磁盘,分担Master Thread的工作

# 数据管理方式
+ 为了数据能够更好的被管理，innoDB采用分级管理的方式，数据被从大到小组织管理，由大到小依次是 表空间 > 段 > 区 > 页
    - 表空间: 表空间是一个逻辑概念，InnoDB 把所有数据保存都在表空间，包括索引，表元数据，用户数据等等，逻辑上它是各种数据的集合，物理上它是多个磁盘文件的集合
    - 段:是表空间下一级的数据集合，是一个逻辑概念，按照数据的类型将数据分开存储形成一个个段，包含索引段，数据段，回滚段等。
    - 区:区是段的基本单位，一个段由一个或者多个区构成，物理上区是一段连续的磁盘空间，大小为1M
    - 页:页是innoDB的基本数据管理单元，innoDB的任何数据都以页的形式存储和读写，每个叶默认了16K,区就是一组连续页，每个区64个页
+ innoDb建立一个索引会分配两个段，一个保存非叶子节点，一个保存叶子节点，段建立初期就会被分一个初始区保存数据，随着数据量的增多，一个区不够保存数据了就会申请新的区，新申请的区隶属于这个段。一个段可以管理256个区，可以一直扩展下去，但是每次扩展最少一个区
+ 页在逻辑上和物理上都是连续的，因为页是属于区的，innoDB每次申请的一个区，区是一段连续的磁盘空间，所以每个页是按顺序排布在这个连续空间中的
+ InnoDB使用B+数作为索引存储结构，而且采用聚集索引，非叶子节点保存的索引值，叶子节点保存数据，这种特性使得表的数据全部存储在索引树上。而在索引树的实现上，每个非叶子节点都是一个页，所以使用索引查询数据，每次经过一个叶子节点都需要一次IO读取一页的数据。这也是为什么采用B+树而非二叉树，B+树每个节点可以保存更多索引数据，比较次数更少进行IO次数也就更少
+ 我们平时插入数据是以“记录”为基本单位，也就是一行数据，行记录是按照主键排序存储在页中的，所以mysql的表必须含有主键，且最好的自曾的，这样在数据存储时页内部就一直以追加的方式存储数据，如果使用UUID作为主键，没插入一条记录都需要在页内部进行排序，数据查询时也无法发挥局部性原理优势

## 缓冲池
1. innoDB数据存储在磁盘,且按照页的方式管理数据,为了提升性能,innoDB开辟了一块内存区域作为缓冲池
2. 每次读取数据时,会优先进入缓冲池查询数据,命中则返回,否则在进行磁盘IO.从磁盘加载的数据也会暂存与缓冲池供下次读取使用
3. 对于数据的修改,也是先更新缓冲池内容,然后系统以checkPoint的方式刷新到磁盘
4. 查询缓冲池大小 show variables like 'innodb_buffer_pool_size';
5. 缓冲池的数据包含索引页,数据页,undo页,锁信息等等,缓冲池可以配置多个,除了缓冲池innodb还包含一些额外的专用缓冲区,比如redo日志缓冲

## innoDB关键技术
1. 插入缓冲
    
    表如果包含自增主键, 因为聚集索引的特性,数据的插入操作是顺序的,效率很高.但是如果表中存在非聚集索引,索引树本身的插入操作很大可能不是顺序的,此时如果此索引树不在缓冲区,就需要随机IO,效率很低.为了减少非聚集索引插入引起的随机IO,插入时会先判断索引是否存在与缓冲池,存在则直接插入,否则现将数据保存在Insert buffer对象,随后再批量的同步到非聚集索引的叶子节点.只有索引属于非聚集索引且非唯一索引, 存储引擎才会使用插入缓冲技术.

2. 两次写
    Mysql以页(DB Page)的方式管理数据,一个DB Page 一般16K,而操作系统的IO最小单元(IO Page)是一般4k,所以如果需要写入一个DB Page,操作系统无法保证写入操作的原子性,那么就会出现一个页写了一半的情况.这就是页断裂(partial write)
    理论上,如果重做日志是以物理日志的方式记录数据,单纯记录每个磁盘的物理地址应该是什么数据,即便出现页断裂恢复数据也不会有什么问题,但是的为了减小日志的体积,重做日志采用逻辑物理日志保存数据,即记录DB Page是记录的绝对的物理地址,但是DB Page内部的数据是逻辑日志.逻辑日志的好处是日志体积小,坏处就是执行起来不是幂等的,依赖页的完整性.比如一个DB Page内部连续写了两个 update a = a+1.出现页断裂时第一条已经执行成功且同步到磁盘,下次恢复的时候,数据引擎也只能从这个页的起始位置重新执行,于是第一条sql会重复执行.为避免这种情况.innodb不允许恢复损坏的DB Page,那就会出现页丢失.
    两次写就是在mysql的存储空间开辟一个2M的磁盘空间作为doublewrite buffer,当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先同步到doublewrite buffer中每次写1MB(顺序写，性能很高);成功以后再将doublewrite buffer中的脏页数据写入实际的各个数据页
    由于两次写只有一个完成以后才会写下一个,所以只可能有一个过程出现页断裂,在恢复数据时,如果数据页发生页断裂,则从doublewrite buffer恢复数据,如果doublewrite buffer发生页断裂,则直接从重做日志恢复数据.
    参考:
    https://www.cnblogs.com/cchust/p/3961260.html

3. 自适应HASH
    
    hash索引的效率很高,一般情况下比B树更高,innodb引擎会监控表查询情况,如果发现为某个列添加hash索引可以提升查询性能,会自动为该列加上hash索引,这种技术称为自适应HASH(AHI)

4. 异步IO

    如果用户发起一次索引扫描查询,这个sql语句可能需要扫描多个索引页,进多次IO操作,如果必须等待一个页扫描完成才能接收下一个io请求是没有必要的.异步IO支持用户发起一个IO请求后立即发起另外一个IO请求,然后等待所有的IO请求全部完成.
    AIO技术还可以将多个IO请求合并为一个IO请求,减少IO次数
