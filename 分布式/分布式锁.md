# 实现方案
+ 基于数据库实现
    - 实现：多个线程去抢占一个key,插入成功就代表获取锁成功;或者同时插入，主键最小的获取锁成功。
    - 优点：实现简单，不需要第三方组件
    - 缺点：速度很慢
+ 基于zookeeper实现
    - 实现：多个线程同时抢占一个临时节点，创建成功的线程代表获取锁成功；或者同时插入顺序节点，节点数值最小的获取锁成功
    - 优点：实现简单，
    - 缺点：速度慢;使用顺序节点的方案可能出现惊群效应
+ 基于redis实现
    - 原理：
        1. 多线程使用 SETNX 命令插入同一个key, 插入成功代表获取锁成功。问题是没有设置key的有效期，一旦客户端因为特殊原因没有主动释放锁，锁会被永久占用
        2. 多线程使用 SET key value NX EX seconds ，此命令以原子的方式插入数据并且设置了TTL.插入成功代表获取锁成功。问题有几个 
            1. 失效时间并不好预估，如果线程执行时间大于TTL锁就有可能同时被其他线程获取,可以使用 Redisson 配合 监控锁(看门狗)解决，设置锁时为key设置TTL,看门狗只要发现Redisson还没断，就会自动的延续这个锁的TTL
            2. redis服务器时间漂移问题，就是redis服务器时间如果比客户端的服务器时间超前，那么key的失效时间就会提前，导致错误
            3. 主从切换问题，如果线程A在主节点获取到了锁，然后redis发生了异常回复另选了主节点，由于从数据同步的延迟性，可能导致线程B在从节点获取到了锁
        3. 红锁实现:
            1. 客户端先获取到本地系统时间
            2. 客户端从集群的5个Master节点(没有从节点)申请相同的key,申请超时时间很短暂，超时没有获取到就立即到下一个节点获取
            3. 有三个获取成功，且获取锁时间总和没有超过TTL就代表获取锁成功，锁的有效时间 = TTL - 获取锁的时间 - 时间漂移   (因为key相同，所以同一时间只有一个线程能获取到三个锁)，如果获取失败，会释放已经获取到的节点锁
            4. 优点是解决了单节点问题，只要集群中大多数节点还在工作能保证Redlock正常工作，解决了时间漂移问题，不存在主从切换。
            5. 缺点是性能降低了一些。还存在一个隐含的问题，所有节点都没有从节点，如果一个节点崩溃就有可能丢失数据，然后重启后之前获取的锁可能就消失了，就有可能导致另外的线程同时获取到锁。为了缓解这种情况，需要把持久化频率开到最高 fsync =always
    - 优点：效率高
    - 缺点: 无论哪种实现都不能保证100%安全

+ 自建一个三方系统
