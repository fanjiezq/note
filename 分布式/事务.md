# 分布式事务理论基础(https://pdai.tech/md/arch/arch-z-transection.html)
## CAP理论
+ 一致性:对于一个分布式系统，如果系统本身数据是一致的，经过了一次修改操作后，整个系统的数据依旧是一致的，就认为这个系统保证了一致性，反之如果对一个节点数据更新，其他节点却没有更新，系统就是不一致的
+ 可用性:是指系统保证在任意时间系统针对每一个请求都能在“合理时间范围”内给出“合适的返回结果“，合理时间范围是指不会超时，因为不同的系统响应时间本就不同，只要符合在正常的响应时间范围即可。合适的返回结果可以是正确结果也可以是正常的失败提示，不能返回一个错误，造成用户对系统的不信任
+ 分区容错性:对于一个分布式系统，部分服务异常不会导致整个系统不可用就是分区容错的
## BASE理论
+ 基本可用:指系统发生故障时允许损失部分可用性，比如损失响应时间延长返回间隔，或者损失部分功能，进行限流和降级
+ 软状态:针对强一致性系统的非0即1的状态，软状态允许中间状态的出现，比如允许节点数据之间的同步延迟，在延迟时间内，整个集群的状态是不一致的
+ 最终一致:不同于强一致性系统数据不一致系统就不可用的情况，最终一致允许数据暂时性的不一致，只保证系统在一定时间内让整个系统最终达到一致状态

# 分布式事务解决方案
## 基于XA协议实现的分布式事务
+ XA协议是一个分布式事务协议，其规定了要实现分布式事务的角色和接口，XA协议规定实现分布式事务必须有一个 事务管理器（Transaction Manager）和 多个资源管理器（Resource Manager）,由TM协调多个RM，控制RM本地事务的提交和回滚。mysql，oracle数据库都实现了XA协议
+ 这种方案实现简单，常用数据库都有实现，但是应用场景有限，专注于数据库层面，无法实现业务层面的事务，而且因为其是阻塞模型，实现事务时会长时间锁住资源，无法应对高并发的情况

# 分布式事务模型(刚性事务)
## 2PC
+ 2PC 是使用XA协议定义的一种分布式事务模型，此模型拥有一个TM和多个RM，在实现事务时，分为两个阶段:
	- 准备阶段:TM接收到客户端的开启事务的请求,TM向所有RM发送消息，RM锁住资源开启本地事务，运行到commit前一步，并向TM汇报是否准备好了最终提交
	- 提交阶段:TM接收到所有RM准备阶段结果，如果所有结果都是Yes，TM向所有RM发送消息同意提交；只要有一个结果为No，TM向所有RM发送消息要求回滚。RM依靠重做日志和回滚日志保证数据的可用性
+ 2PC缺点如下
	- 性能很低，在准备阶段，所有的资源都会被锁住，只有到第二阶段完成后才会释放
	- 在网络抖动的情况下可能出现数据的不一致，在commit时，如果网络抖动，部分rm延迟commit，或者某些RM刚好在COMMIT之前宕机，在一定时间内整个集群数据是不一致的
	- 存在单点故障，一旦TM宕机，所有RM都会被长久阻塞在commit前一步，因为RM没有超时机制，在选举出新的TM之前系统都是不可用状态

## 3PC
+ 3PC步骤如下
	- CanCommit：协调者向所有参与者发送CanCommit命令，询问是否可以执行事务提交操作。如果全部响应YES则进入下一个阶段。
	- PreCommit：协调者向所有参与者发送PreCommit命令，询问是否可以进行事务的预提交操作，参与者接收到PreCommit请求后，如参与者成功的执行了事务操作，则返回Yes响应，进入最终commit阶段。一旦参与者中有向协调者发送了No响应，或因网络造成超时，协调者没有接到参与者的响应，协调者向所有参与者发送abort请求，参与者接受abort命令执行事务的中断。
	- DoCommit：在前两个阶段中所有参与者的响应反馈均是YES后，协调者向参与者发送DoCommit命令正式提交事务，如协调者没有接收到参与者发送的ACK响应，会向所有参与者发送abort请求命令，执行事务的中断。
+ 3PC的优点是RM也有超时机制，解决了因单点异常导致的长时间阻塞，但是还是没有解决数据不一致问题

## 基于定期校对的分布式事务
+ 定期校对实现分布式事务与 基于可靠消息服务的分布式事务 思想类似，因为后者对消息中间件的要求很高，如果不想使用消息中间件，可以使用这种方式，实现步骤如下：
	1. 上游系统A 完成事务，并向中间件 C(可以是zk或者数据库) 发送确认消息，消息发送成功后系统A认为事务完成，转而去处理其他任务
	2. 中间件收到消息后负责将该消息同步投递给相应的下游系统B，并触发下游系统B的任务执行；
	3. 当下游系统处理成功后，向中间件反馈确认应答，消息中间件便可以将该条消息删除，从而该事务完成。
+ 此方案的主要问题有两点：
	+ 消息从 A 到 C 可能丢失：在A本地建立消息表，每次处理完数据后将消息存入本地表，另外建立一个消息发送者向中间件发送消息，实现重试机制保证消息一定可以发送成功。
	+ 消息从 C 到 B 可能丢失：由系统B不断重试，如果到达一定次数还失败，建立警报机制，人工干预
+ 此方案的优点是实现简单，对中间件的要求不高，适用范围广；缺点系统整体不一致的周期比较长

## 基于可靠消息服务的分布式事务
+ 利用一个消息中间件作为多个系统的连接桥梁，假设场景是存在上游系统A，下游系统B和消息中间件C，两个系统需要实现分布式事务，实现步骤如下：
	1. A 在开始事务前发一个消息给中间件C，让消息持久化但是不投递
	2. C将消息持久化成功后向A发送确认消息，A开始正式执行事务，执行完成后向C提交结果
		- A事务执行成功，向C发送commmit投递消息，中间件后续会将消息发给系统B。此时A认为整个分布式事务已经完成，至于与B相关的部分由消息中间件利用重试机制保证成功
		- A事务实现失败，向C发送rollback, 中间件C删除之前持久化的消息，整个事务结束
	3. 此方式利用base理论，在B完成事务的这段时间，整个系统状态是不一致的，但是最终会变为一致
	4. 此方式强依赖消息系统的可靠，消息系统必须保证在B完成后半段事务之前消息不会丢失，且B必须成功不能失败，因为A一旦提交成功就不再回滚
	5. 为了系统的效率，系统A向中间件C发送执行结果时是异步的，发送完就离开了，并不关心中间件是否收到了结果，这能保证A不会被阻塞，但是消息发送结果不能保证，所以中间件自己提供了超时询问机制，当长时间没有接收到系统A的执行结果，会主动询问系统A，以此保证最终可以拿到结果进行后续操作
	6. 异步提交消息让系统变得很复杂，因为上游服务一般需要面对客户，为提升实时性才采用此方案，下游服务消息的确认使用同步即可
+ 这种方案的优点是可以支持高并发，缺点是实现复杂，而且消息中间件必须支持事务型消息

## 基于TCC的分布式事务(柔性事务)
+ TCC 就是Try/Confirm/Cancel ，顾名思义，此模型分为三个阶段，以转账为例，A从支付宝向工行卡转账10000元
	1. Try: 先从支付宝余额减少10000，并将10000保存在冻结表，将A的工行卡余额增加10000，并记录为预增加
	2. Confirm: 清除冻结表的数据，更新预增加状态为已增加
	3. Cancel: 前两个阶段任何一个阶段失败，都会进入cancel，Cancel会记录两个系统的增减记录，任何情况都可以回滚
+ TCC 模型的核心就是资源冻结和中间状态，其适用性非常广，几乎可以在任何业务中实现此模型，缺点如下:
	1. 代码入侵性强，接口必须改造成TCC规定的模式
	2. 可能有幂等问题，为了应对网络波动，我们经常在Confirm和cancel阶段加入重试机制，重试就必须保证多次操作是幂等的