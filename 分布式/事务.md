# 分布式事务理论基础
## CAP理论
## BASE理论

# 分布式事务模型
## 2PC
+ 2PC 是使用XA协议定义的一种分布式事务模型，此模型拥有一个TM和多个RM，在实现事务时，分为两个阶段:
	- 准备阶段:TM接收到客户端的开启事务的请求,TM向所有RM发送消息，RM锁住资源开启本地事务，运行到commit前一步，并向TM汇报是否准备好了最终提交
	- 提交阶段:TM接收到所有RM准备阶段结果，如果所有结构都是Yes，TM向所有RM发送消息同意提交；只要有一个结果为No，TM向所有RM发送消息要求回滚。RM依靠重做日志和回滚日志保证数据的可用性
+ 2PC 模型的优点是理解和实现简单。缺点是性能很低，在准备阶段，所有的资源都会被锁住，只有到第二阶段完成后才会释放；而且TM存在单点故障，一旦TM宕机，所有RM都会被长久阻塞，因为RM没有超时机制

## 3PC
+ 3PC 模型是 2PC 模型的升级版，主要是为了解决2PC 模型的两个缺点，但是其底层思想还是一样，也是使用XA协议实现。3PC模型实现事务份三个阶段
	- 准备阶段(CanCommit):TM接收到客户端的开启事务的请求,TM向所有RM发送消息，询问RM资源是否可用，是否可以锁住资源，如果可以锁住资源返回Yes，否则返回No
	- 预提交阶段(PreCommit):当所有RM都准备好了，TM向所有RM发送消息，RM锁住资源开启本地事务，运行到commit前一步，并向TM汇报是否准备好了最终提交
	- 提交阶段(DoCommit):TM接收到所有RM准备阶段结果，如果所有结构都是Yes，TM向所有RM发送消息同意提交。在前两步只要有一个RM返回NO，整个事务都会失败
+ 3PC 模型为RM也添加了超时机制，避免TM宕机时RM永久性的阻塞
+ 3PC 模型太复杂，而且对整体性能的提升有限，没有具体的实现


# 分布式事务解决方案
## 基于XA协议实现的分布式事务
+ XA协议是一个分布式事务协议，其规定了要实现分布式事务的角色和接口，XA协议规定实现分布式事务必须有一个 事务管理器（Transaction Manager）和 多个资源管理器（Resource Manager）,由TM协调多个RM，控制RM本地事务的提交和回滚。mysql，oracle数据库都实现了XA协议
+ 这种方案实现简单，常用数据库都有实现，但是应用场景有限，专注于数据库层面，无法实现业务层面的事务，而且因为其是阻塞模型，实现事务时会长时间锁住资源，无法应对高并发的情况

## 基于可靠消息服务的分布式事务
+ 利用一个消息中间件作为多个系统的连接桥梁，假设场景是存在上游系统A，下游系统B和消息中间件C，两个系统需要实现分布式事务，实现步骤如下：
	1. A 在开始事务前发一个消息给中间件C，让消息持久化但是不投递
	2. C将消息持久化成功后向A发送确认消息，A开始正式执行事务，执行完成后向C提交结果
		- A事务执行成功，向C发送commmit投递消息，中间件后续会将消息发给系统B。此时A认为整个分布式事务已经完成，至于与B相关的部分由消息中间件利用重试机制保证成功
		- A事务实现失败，向C发送rollback, 中间件C删除之前持久化的消息，整个事务结束
	3. 此方式利用base理论，在B完成事务的这段时间，整个系统状态是不一致的，但是最终会变为一致
	4. 此方式强依赖消息系统的可靠，消息系统必须保证在B完成后半段事务之前消息不会丢失，且B必须成功不能失败，因为A一旦提交成功就不再回滚
	5. 为了系统的效率，系统A向中间件C发送执行结果时是异步的，发送完就离开了，并不关心中间件是否收到了结果，这能保证A不会被阻塞，但是消息发送结果不能保证，所以中间件自己提供了超时询问机制，当长时间没有接收到系统A的执行结果，会主动询问系统A，以此保证最终可以拿到结果进行后续操作
	6. 异步提交消息让系统变得很复杂，因为上游服务一般需要面对客户，为提升实时性才采用此方案，下游服务消息的确认使用同步即可
+ 这种方案的优点是可以支持高并发，缺点是实现复杂，而且消息中间件必须支持事务型消息

## 基于定期校对的分布式事务
+ 定期校对实现分布式事务与 基于可靠消息服务的分布式事务 思想类似，实现步骤如下：
	1. 上游系统A 完成事务，并向中间件 C 发送确认消息，消息发送成功后系统A认为事务完成，转而去处理其他任务
	2. 消息中间件收到消息后负责将该消息同步投递给相应的下游系统B，并触发下游系统B的任务执行；
	3. 当下游系统处理成功后，向消息中间件反馈确认应答，消息中间件便可以将该条消息删除，从而该事务完成。
+ 此方案的主要问题有两点：
	+ 消息从 A 到 C 可能丢失：在A本地建立消息表，每次处理完数据后将消息存入本地表，另外建立一个消息发送者向中间件发送消息，实现重试机制保证消息一定可以发送成功。
	+ 消息从 C 到 B 可能丢失：中间件本身就存在消息重试机制，如果重试次数到达后进入一个死信队列，由系统B定期检查死信队列，主动消费消息，如果还不能解决，建立警报机制，人工干预
+ 此方案的优点是实现简单，对中间件的要求不高，适用范围广；缺点系统整体不一致的周期比较长

## 基于TCC的分布式事务
+ TCC 就是Try/Confirm/Cancel ，顾名思义，此模型分为三个阶段，以转账为例，A从支付宝向工行卡转账10000元
	1. Try: 先从支付宝余额减少10000，并将10000保存在冻结表
	2. Confirm: 将A的工行卡余额增加10000，事务结束
	3. Cancel: 前两个阶段任何一个阶段失败，都会进入cancel，释放支付宝余额冻结的10000元
+ TCC 模型的好处是适用性非常广，几乎可以在任何业务中实现此模型，缺点是代码入侵性强，接口必须改造成TCC规定的模式
