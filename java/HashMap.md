# 实现原理
+ HashMap 简单来说就是一个链表数组，基础是一个数组，每个数组元素是一个链表(Entry)
+ 元素存储时会先对key进行hash计算，然后对数组length取模，确认元素应该保存在数组的哪个位置，如果该位置已经被占用，则比较key值，不相同就保存在当前元素后面，形成链表
+ 当某个链表的数量大于8时，链表会转为红黑树，提升查找效率

# 扩容机制
+ HashMap有两个核心参数，数组大小哦(capacity)和负载因子(loadFactor)。数组大小不必说默认16，负载因子是为了控制数据的密集程度，默认0.75
+ 当HashMap存储的 元素总数 > capacity * loadFactor,数组容量会扩展到原来的两倍，扩容的目的是为了减少hash碰撞，碰撞越多，链表就越长，查询插入和查询效率越低
+ 还有一种情况会触发扩容，就是元素不多，但是也形成了比较长的链表，但是此时数组太小(小于64)会进行扩容，虽然元素数量没有达到标准，但是数据分布不均匀，进行一次扩容成本很低，但是能很好的解决问题
