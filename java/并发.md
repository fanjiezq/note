# java内存模型
+ java为了屏蔽硬件之间的内存差异,自己定义了一个内存模型,保证java程序在任何平台都可以稳定的运行
+ java的内存模型是建立在jvm虚拟机上的,所以java内存模型中的内存,概念上属于jvm虚拟机申请的物理内存的子集
+ java内存模型将内存分为两部分,主内存和工作内存,主内存属于公共内存,被线程共享,工作内存是线程私有内存
+ java线程只会操作工作内存的数据,如果数据保存在主内存,也会先将数据从主内存加载到工作内存,操作完成后再写回到主内存

# 保证线程安全的手段
## volatile 型变量
+ volatile变量是最轻量级的线程同步手段,它有两个特点
    - 线程对volatile变量的修改,其他线程都能看到
    - volatile变量可以防止指令重排序,避免因为编译器优化导致的逻辑错误,最常用于 双重锁检测
+ volatile 变量修改可以被所有线程感知的实现原理是,线程每次使用volatile变量,都会从主内存获取,每次修改完成后也会第一时间写回主内存
+ volatile变量的修改虽然可以被其他线程感知,但是它并不能保证多线程情况下的数据安全,volatile变量适合多线程之间共享变量状态变化的通知,因为只要变量被一个线程修改,其他线程都能感知到

## 使用原子类
+ 出现线程安全很大比例都是更新丢失问题,即一个线程正在更新一个变量(比如自增)时另一个线程同时也更新了这个变量,本来是两次更新,但是结果却只是一次更新的效果
+ 出现更新丢失问题的核心在于更新操作这个动作对线程来说并非原子操作,如果保证更新操作是原子的,即线程更新过程中是不可被打断的,即便是被打断本次更新也会被回滚,就能保证不出现更新丢失,java提供了原子变量类专门用于解决此类问题
+ 原子变量类的实现原理是CAS(compare and swap),即县城在进行更新操作开始先记录下变量值,到最终进行最后一步赋值操作时检查,一次变量是否等于开始记录的变量,如果相等则说明更新过程中,变量没有改变可以正常操作,否则不进行更新
 
## 加锁
+ 原子类能解决丢失更新的问题,但它只适合变量修改, 适用场景十分有限.许多复杂业务需要使用锁来解决竞争条件保证数据安全
+ 锁是解决多线程安全的最常用手段,java有很多类型的锁,最常用的是synchronized关键字创建的锁.锁类型和实现差别很大,基本原理是一致的,就是线程执行到临界区域时需要首先获取到一个锁对象才可以进入临界区域,锁对象一旦被一个线程获取必须等到释放后其他线程释放才可以获取,以此保证同一时间只有一个线程可以进入临界区域执行代码


# 锁
## 锁分类
+ 自旋锁VS非自旋锁
+ 可重入所VS不可重入锁
+ 读写锁
+ 偏向锁

## 锁实现原理


## 常用锁



# 常用线程安全类



# 同步容器类(使用了synchronized)
+ Vector
+ HashTable

# 并发容器
+ ConcurrentHashMap:线程安全的map,用于替代HashTable,使用分段锁保证线程安全,减小了锁的粒度,提升了并发性
+ CopyOnWriteArrayList:List的线程安全版本,用于替代Vector,使用写时复制保证线程安全.即在线程对容器进行修改时,java会自动拷贝一份数据,所有的修改都在此数据上面
+ CopyOnWriteArraySet:Set的安全版本,写时复制技术



# 线程池